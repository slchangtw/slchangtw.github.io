<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Be a Problem Solver</title><link>https://slchangtw.github.io/tags/python/</link><description>Recent content in Python on Be a Problem Solver</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Oct 2023 10:43:32 +0800</lastBuildDate><atom:link href="https://slchangtw.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Managing Project Dependencies with Poetry</title><link>https://slchangtw.github.io/posts/20231004_poetry_packages/</link><pubDate>Wed, 04 Oct 2023 10:43:32 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231004_poetry_packages/</guid><description>&lt;p>Throughout the development of Python projects, incorporating third-party packages becomes essential. The conventional approach for managing project dependencies involves using a &lt;code>requirements.txt&lt;/code> file. However, it&amp;rsquo;s easy to overlook updating this file with newly installed packages using &lt;code>pip freeze &amp;gt; requirements.txt&lt;/code>. Moreover, it can be challenging to tell which dependencies were installed directly or indirectly via &lt;code>requirements.txt&lt;/code>, making it unclear which packages are genuinely essential after removing some.&lt;/p>
&lt;p>To address these issues, it&amp;rsquo;s recommended to adopt a modern package manager like &lt;code>poetry&lt;/code> for more efficient project dependency management.&lt;/p></description></item><item><title>Using pytest to Test Your Code</title><link>https://slchangtw.github.io/posts/20231001_pytest/</link><pubDate>Sun, 01 Oct 2023 21:06:47 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231001_pytest/</guid><description>&lt;p>Have you ever found yourself inheriting legacy code and questioned its functionality after refactoring? Or, have you made changes to your code and wondered if it still works correctly? If you&amp;rsquo;ve experienced either of these scenarios, it&amp;rsquo;s time to consider implementing tests for your code. In this article, we will cover the basics of pytest for conducting unit tests.&lt;/p></description></item><item><title>Principle of Clean Python Code - Naming, Comments, Functions</title><link>https://slchangtw.github.io/posts/20230928_python_clean_code_naming_comment_function/</link><pubDate>Thu, 28 Sep 2023 20:42:31 +0800</pubDate><guid>https://slchangtw.github.io/posts/20230928_python_clean_code_naming_comment_function/</guid><description>&lt;p>Writing clean code is a fundamental goal to enhance code readability, comprehension, and maintainability. It is considered a best practice to adhere to clean code principles when developing in Python. In this article, we will explore key principles of clean Python code, focusing on naming conventions, commenting practices, and function design.&lt;/p></description></item><item><title>Using pyenv to Manage Python Versions</title><link>https://slchangtw.github.io/posts/20230925_pyenv/</link><pubDate>Mon, 25 Sep 2023 10:06:07 +0800</pubDate><guid>https://slchangtw.github.io/posts/20230925_pyenv/</guid><description>&lt;p>During development, you may require different Python versions for various projects. For example, you might need Python 3.6 for one project and Python 3.10 for another. Instead of installing different Python versions on your system, you can use pyenv to manage multiple Python versions.&lt;/p></description></item></channel></rss>