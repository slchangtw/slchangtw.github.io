<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Be a Problem Solver</title><link>https://slchangtw.github.io/posts/</link><description>Recent content in Posts on Be a Problem Solver</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 Oct 2023 14:24:50 +0800</lastBuildDate><atom:link href="https://slchangtw.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Github Actions for Automated Testing</title><link>https://slchangtw.github.io/posts/20231013_github_actions/</link><pubDate>Fri, 13 Oct 2023 14:24:50 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231013_github_actions/</guid><description>&lt;p>Testing plays a crucial role in software development. When you&amp;rsquo;ve completed a code module and wish to merge it into the main branch, it&amp;rsquo;s essential to ensure that the code adheres to the style guidelines and functions correctly. This is where testing becomes crucial. Since testing is a repetitive task, automating the testing process can greatly reduce the time and effort required to validate the code. Therefore, in this post, I&amp;rsquo;ll demonstrate how to utilize GitHub Actions for automating the testing process, which encompasses checking code formatting, linting, and running unit tests&lt;/p></description></item><item><title>Ensuring Code Quality with pre-commit Hooks</title><link>https://slchangtw.github.io/posts/20231011_precommit/</link><pubDate>Wed, 11 Oct 2023 20:42:38 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231011_precommit/</guid><description>&lt;p>A hallmark of clean code is consistent formatting, which becomes important when collaborating in a team. While manually using formatters or linters to check code is possible, it&amp;rsquo;s easy to forget. A more effective approach is to use tools like pre-commit hooks for automated code inspection before committing&lt;/p></description></item><item><title>Testing Functions with Localstack for Cloud Service Interactions</title><link>https://slchangtw.github.io/posts/20231008_localstack_for_tests/</link><pubDate>Sun, 08 Oct 2023 15:31:49 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231008_localstack_for_tests/</guid><description>&lt;p>In software development, it&amp;rsquo;s common to write functions that interact with cloud services. Instead of testing these functions against the actual cloud services, we can utilize Localstack to create local mock versions of these services. This approach enables us to test our functions without network dependencies and without altering the state of the real cloud services. In this post, we will explore how to use Localstack to test functions that interact with AWS DynamoDB.&lt;/p></description></item><item><title>Using Docker to Run Your Python Tests</title><link>https://slchangtw.github.io/posts/20231005_build_docker_image/</link><pubDate>Thu, 05 Oct 2023 09:27:00 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231005_build_docker_image/</guid><description>&lt;p>Have you ever come across the infamous &amp;lsquo;It works on my machine&amp;rsquo; issue? I&amp;rsquo;m sure you haveâ€”it&amp;rsquo;s a common challenge in software development. To tackle this problem, Docker containers offer a solution by allowing you to encapsulate your code and execute it in a consistent environment. As a result, Docker is widely adopted in various domains, including the automation of CI/CD pipelines. In this article, I will demonstrate how to leverage Docker to create and execute a Python test environment.&lt;/p></description></item><item><title>Managing Project Dependencies with Poetry</title><link>https://slchangtw.github.io/posts/20231004_poetry_packages/</link><pubDate>Wed, 04 Oct 2023 10:43:32 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231004_poetry_packages/</guid><description>&lt;p>Throughout the development of Python projects, incorporating third-party packages becomes essential. The conventional approach for managing project dependencies involves using a &lt;code>requirements.txt&lt;/code> file. However, it&amp;rsquo;s easy to overlook updating this file with newly installed packages using &lt;code>pip freeze &amp;gt; requirements.txt&lt;/code>. Moreover, it can be challenging to tell which dependencies were installed directly or indirectly via &lt;code>requirements.txt&lt;/code>, making it unclear which packages are genuinely essential after removing some.&lt;/p>
&lt;p>To address these issues, it&amp;rsquo;s recommended to adopt a modern package manager like &lt;code>poetry&lt;/code> for more efficient project dependency management.&lt;/p></description></item><item><title>Using pytest to Test Your Code</title><link>https://slchangtw.github.io/posts/20231001_pytest/</link><pubDate>Sun, 01 Oct 2023 21:06:47 +0800</pubDate><guid>https://slchangtw.github.io/posts/20231001_pytest/</guid><description>&lt;p>Have you ever found yourself inheriting legacy code and questioned its functionality after refactoring? Or, have you made changes to your code and wondered if it still works correctly? If you&amp;rsquo;ve experienced either of these scenarios, it&amp;rsquo;s time to consider implementing tests for your code. In this article, we will cover the basics of pytest for conducting unit tests.&lt;/p></description></item><item><title>Principle of Clean Python Code - Naming, Comments, Functions</title><link>https://slchangtw.github.io/posts/20230928_python_clean_code_naming_comment_function/</link><pubDate>Thu, 28 Sep 2023 20:42:31 +0800</pubDate><guid>https://slchangtw.github.io/posts/20230928_python_clean_code_naming_comment_function/</guid><description>&lt;p>Writing clean code is a fundamental goal to enhance code readability, comprehension, and maintainability. It is considered a best practice to adhere to clean code principles when developing in Python. In this article, we will explore key principles of clean Python code, focusing on naming conventions, commenting practices, and function design.&lt;/p></description></item><item><title>Using pyenv to Manage Python Versions</title><link>https://slchangtw.github.io/posts/20230925_pyenv/</link><pubDate>Mon, 25 Sep 2023 10:06:07 +0800</pubDate><guid>https://slchangtw.github.io/posts/20230925_pyenv/</guid><description>&lt;p>During development, you may require different Python versions for various projects. For example, you might need Python 3.6 for one project and Python 3.10 for another. Instead of installing different Python versions on your system, you can use pyenv to manage multiple Python versions.&lt;/p></description></item></channel></rss>